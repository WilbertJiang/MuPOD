# Welcome to MuPOD!
MuPOD is a data-driven thermal simulator that can be dynamically reorganized to adapt to variations in chip floorplans.
This `README.md` provides step-by-step guidance on installing and using MuPOD. The simulator can also be seamlessly integrated into EDA toolchains as an efficient and accurate thermal model.
This work was recognized with the Prof. Avram Bar-Cohen [Best Paper Award at ITherm 2022](https://www.ieee-itherm.net/2022-best-paper-winners/).

<p align="center">
  <img src="/Image/BPA.jpg" alt="Best Paper Award" width="600">
</pr>

If you use any component of MuPOD in your work, please cite:

```
[1] L. Jiang, A. Dowling, Y. Liu and M. -C. Cheng, "Chip-level thermal simulation for a multicore processor using a multi-block model enabled by proper orthogonal decomposition"
ITherm (2022), p. 2022
```


# Overview
MuPOD combines Proper Orthogonal Decomposition (POD) with domain decomposition:

**1. Partitioning into Blocks**:
The chip is divided into smaller building blocks (cores, caches, I/O, memory, etc.) based on its floorplan. Each block is simulated individually with a high-resolution FEM tool [FEniCS](https://fenicsproject.org/).

**2. Training POD Modes**:
For each block, dynamic thermal data is collected under varying power and boundary conditions. POD extracts a small set of basis functions (modes) capturing most of the thermal behavior. These modes form a reduced-order model (ROM) for the block.

**3. Dynamically Assembling the Multi-Block Model**:
Block-level POD models are combined into a chip-level simulator for the entire chip. At block interfaces, the discontinuous Galerkin (DG) method enforces thermal continuity by balancing temperature and heat flux across boundaries.

PODTherm-GP includes several components and each C++ component can be compiled in its folder by the following  
```
    cd ./src  
    ffc -l dolfin Space.ufl  
    cd ..  
    mkdir build  
    cd ./build  
    cmake ..  
    make 
 ```
 Then the executable file can be run with one or multiple processes. For instance, the component of training data collection can be performed by 
 ```
 mpirun -n 20 ./Therm_FEM
 ```
where 20 is the number of processes. However, for this version PODTherm-GP, [ODE solver](https://github.com/WilbertJiang/PODTherm_GP/tree/main/ODE_Solver_CU) doesn't support MPI.   

# Dependencies
**FEniCS platform installation**:  
PODTherm-GP thermal simulator is developed on the FEniCS platform, which provides a flexible framework for solving partial differential equations (PDEs) using finite element methods. FEniCS should be pre-installed using the following command:  
```
sudo apt-get install --no-install-recommends software-properties-common  
sudo add-apt-repository ppa:fenics-packages/fenics  
sudo apt-get update  
sudo apt-get install fenics
```
Please refer to the FEniCS installation guide for more detailed instructions on installation and troubleshooting: [FEniCS download](https://fenicsproject.org/download/.).

**Building tools installation**:   
To run the C++ version FEniCS, you need to make sure that the build tools are installed
```
sudo apt install cmake make g++ -y
```
**C++ FEniCS installation**:  
If the cmake are installed on your server, you can then run the following commands to install C++ version FEniCS
```
sudo apt-get install --no-install-recommends software-properties-common
sudo add-apt-repository ppa:fenics-packages/fenics
sudo apt-get update
sudo apt-get install --no-install-recommends fenics
```

# POD Model Training
The entire training process of PODTherm-GP includes three steps.  
**1. Training data collection:** The training temperature data for the generation of PODTherm-GP can be collected via direct numerical simulations (DNSs) such as the finite element method (FEM), or experimental measurements. In this project, we collect the temperature data via FEniCS using FEM and the code located in [./Data_Collection_FEM](https://github.com/WilbertJiang/PODTherm_GP/tree/main/Data_Collection_FEM). It can be performed by the following  

```
mpirun -n 20 ./Therm_FEM
```
  

    
**2. POD mode generation:** With collected training temperature data, POD modes can be generated by the following    
```
cd ./Calculate_A/build  
mpirun -n 20 ./calculate_A_Matrix  
cd ../..  
cd ./Eigensolver/build  
./Eigensolver ../../A.csv  
cd ../..  
cd ./Get_POD_Modes_FEniCS/build  
./get_POD_Modes  
cd ../..  
```
**3. Estimation of POD parameters:** Once the POD modes are generated, the physical principle can also be projected via the Galerkin projection as described in [ISCAS2022](https://ieeexplore.ieee.org/abstract/document/9937274). It results in a set of ordinary differential equations (ODEs) and the POD parameters can be obtained by  
Thermal conductance matrix: **G**
```
cd ./Calculate_G/build/  
./calculate_G_Matrix  
cd ../..  
```
Thermal capacitance matrix: **C**
```
cd ./Calculate_C/build  
./calculate_C_Matrix  
cd ../..
```
Power density in POD space: **P**
```
cd ./Calculate_P/build   
./calculate_P_Matrix   
cd ../..  
```
# Thermal Simulation via PODTherm-GP  
After [POD Model Training](https://github.com/WilbertJiang/PODTherm_GP/blob/main/README.md#pod-model-training), PODTherm-GP is ready to perform thermal simulations of the semiconductor chips. It can be done as follows   
Fristly, create a `pod_result` folder to store the result.  
```
mkdir pod_result  
```
Compute the power density in POD space  
```
cd ./Calculate_P/build   
./calculate_P_Matrix   
cd ../..  
```
Solve the temperature in POD Space
```
cd ./ODE_Solver_CU/build  
./Calculate_CU  
```
To restore the temperature in the physical space, a post processing is required. This procedure is very flexible such that you can just restore the temperature over the interesting regions (such as Cores) and time steps, instead of  over the entire semiconductor chip and each time step. In this repo, `Post_Processing.py`, is provided to perform the post processing, which is however over the entire semiconductor chip and all time steps to compute the least sqaure (LS) error of the thermal simualtions via PODTherm-GP against FEniCS-FEM.  
```
python Post_Processing.py  
```
If the LS error isn't required, you can modify `Post_Processing.py` to perform the post processing over the region of interest and some of time steps.
# Example of AMD ATHLON II X4 610e CPU
In this repo, a simple example is given by the thermal simulation of AMD ATHLON II X4 610e CPU whose floorpan is shown at below, and all parameters are included in [POD_Para.xml](https://github.com/WilbertJiang/PODTherm_GP/blob/main/POD_Para.xml). The training and prediction dynamic power maps are [powertrace_AMD_240.txt](https://github.com/WilbertJiang/PODTherm_GP/blob/main/powertrace_AMD_240.txt) and [powertrace_AMD_240_pre.txt](https://github.com/WilbertJiang/PODTherm_GP/blob/main/powertrace_AMD_240_pre.txt), respectively, which can be specified via ` <variable name="Power_path_in">../../powertrace_AMD_240.txt</variable>` in the [POD_Para.xml](https://github.com/WilbertJiang/PODTherm_GP/blob/main/POD_Para.xml).



The example can be run step by step as described in this `README.md` or using the shell script
 ```
 ./Model_Training.sh  
./Prediction_Model.sh  
```
When you use the above shell scripts, it should be kept in mind that you should use different dynamic power maps for the training and demonstration of PODTherm-GP by changing ` <variable name="Power_path_in">../../powertrace_AMD_240.txt</variable>` in the [POD_Para.xml](https://github.com/WilbertJiang/PODTherm_GP/blob/main/POD_Para.xml).

The LS error of AMD ATHLON II X4 610e CPU example over the entire spatial and temporal domain is


